---
title: Java内存区域与内存溢出异常
date: 2018-01-16 18:36:36
comments: true
---

### 1、内存泄漏和内存溢出的区别？
我的见解：
&emsp;&emsp;内存溢出 （out of memory）：程序在申请内存时，没有足够的内存空间供其使用；比如：找人借钱，你借1w，但是他只有5000，你从他这根本借不到你需要的1w，对于他（内存）来说，要满足你，必须溢出才可以。
&emsp;&emsp;内存泄漏（memory leak）：程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。比如：这就是传说中的借钱不还，借一次两次还好，但一直借，多了的话，被借的人的钱迟早会被你借完，最终还会导致内存溢出。

[参考博客] : http://blog.csdn.net/buutterfly/article/details/6617375

### Java虚拟机所管理的内存将会包含以下几个运行时数据区域：如下图所示：
![JVM运行时内存区域](/upload_image/java01.png "JVM运行时内存区域")

### 下面分析一下上图片中各个内存区域的作用：
#### （1）程序计数器
&emsp;&emsp;它是一块较小的内存空间；它可被看作是当前线程所执行的字节码的行号指示器（即当前线程正在执行哪行代码）；程序在执行的过程中需要依赖它来知道下一条执行哪条语句；JVM的多线程是通过线程轮流切换实现的，为了线程切换后能恢复到正确的位置，所以每个线程都要有一个独立的程序计算器来记录它上次执行到哪行代码了，以便下次接着执行。所以它是线程私有的内存。该内存区域是唯一一个在Java虚拟机规范中没有规定任何内存溢出情况的区域。
总结：程序计数器是一块比较小的内存，主要用来记录当前线程执行到哪行代码了，是线程私有的，是唯一一个没有规定任何内存溢出情况的区域。
#### （2）Java虚拟机栈
&emsp;&emsp;它是线程私有的，与线程同生共死；它描述的是Java方法执行的内存模型：每个方法在执行的时候都会创建一个栈帧，方法从调用到完成对应着栈帧在虚拟机中入栈到出栈的过程，栈帧里主要保存着：方法所需的各种变量包括基本数据类型和引用数据类型的引用、方法的返回值信息等。规定了两种异常：如果线程请求栈的深度大于虚拟机所允许的深度，抛出StackOverflowError；如果无法申请到足够的内存，抛出OutOfMemoryError异常。
总结：Java虚拟机栈是线程私有的，生命周期跟线程同步，这块内存主要描述Java方法执行时内存的使用，比如：存储方法中用到的变量，方法的返回值信息等。规定了两种异常。
#### （3）本地方法栈
&emsp;&emsp;它与虚拟机栈发挥的作用相似，区别是Java虚拟机栈是为执行Java方法服务的，而本地方法栈是为虚拟机使用到的Native方法（即调用本机操作系统中的方法）服务。与虚拟机栈一样，抛出两种异常。同样也是线程私有的。
#### （4）Java堆
&emsp;&emsp;它是Java虚拟机管理的内存中最大的一块，被所有线程共享。用来存放对象实例的。它同时也是垃圾收集器管理的主要区域。说白了就是对象实例分配与回收的地方，内存不够时会抛出OutOfMemeoryError异常。
#### （5）方法区（这名字起得有点怪，个人感觉跟方法没多大关系，应该叫全局区或者类区更贴切一点）
&emsp;&emsp;它是线程共享的，用来存储已经被JVM加载的类信息、常量、静态变量等数据。Java虚拟机规范对此内存区域的限制非常宽松，可以不实现垃圾收集，但是这个是不可取的。该区域可能会抛出OutOfMemoryError异常。
#### （6）运行时常量池
&emsp;&emsp;它是方法区的一部分，在类加载后将（编译期生成的各种字面量和符号引用即常量池中的内容）放入到该内存中。可能会抛出OutOfMemoryError异常。
#### （7）直接内存
&emsp;&emsp;注意：它不属于虚拟机运行时数据区的一部分，也不是Java虚拟机规范定义的内存区域。但是由于这部分内存被频繁的使用，所以在这里统一讲解。位于Java堆之外的系统内存，由于管理员很容易忽略这部分内容，从而导致动态扩展时抛出OutOfMemoryError异常。



