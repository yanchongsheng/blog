---
title: Linux 入门总结(二)
copyright: true
date: 2018-09-06 20:00:23
updated:
comments:
tags: Linux 基础
categories: Linux 基础
layout:
permalink:
top:
password:
---

<blockquote class="blockquote-center"> Linux 入门总结(二) —— Linux 系统安装 </blockquote>

<!-- more -->

## 磁盘分区
磁盘分区又叫系统分区，是使用分区编辑器（partition editor）在磁盘上划分几个逻辑部分。从字面意思来讲，磁盘分区指的就是把大的硬盘按照我的需求划分成几个分区，不同类目录与文件可以存储进不同的分区。

## 分区类型
1. 主分区：最多只能有 4 个。  
2. 扩展分区「是从主分区的 4 个分区之中拿出 1 个分区作为扩展分区」：
> * 扩展分区最多只能有 1 个（注意：针对一块硬盘来讲，一个硬盘最多只能有一个扩展分区）。
> * 主分区加扩展分区最多只能有 4 个。
> * 扩展分区本身不能写入数据也不能格式化，唯一的作用就是用来包含逻辑分区。

3. 逻辑分区「即扩展分区中的逻辑分区」：可以正确的写入数据和格式化。按照硬盘的限制，一块硬盘最多只能分 4 个分区，即 4 个主分区。这种限制不是 Linux 系统的限制而是硬盘本身的限制，只要硬盘结构不发生变化，这种限制会一直存在。

## 格式化
硬盘正确分区以后还不能写入数据，硬盘还必须经过格式化以后才可以写入数据。

格式化 (高级格式化) 又称逻辑格式化，它是指根据用户选定的文件系统（如 fat16、fat32、NTFS、ext2、ext3、ext4 等），在磁盘的特定区域写入特定数据，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。

在 windows 中可以识别的文件系统有 fat16、fat32、NTFS，在 linux 中可以识别的文件系统有 ext2、ext3、ext4，centOS 默认使用的是 ext4。

硬盘的格式化最主要的目的就是为了在硬盘当中写入文件系统，写入文件系统最主要的工作就是按照文件系统的规则把硬盘分成等大小的数据块，然后建立 iNode 表，我们把表里的编号称为 i 节点号又名 iNode 号。

当在查找文件的时候，是通过 iNode 表找到 i 节点号来找到这个文件的条款，从而知道这个文件保存在哪几个数据块之中，从而找到这几个数据块拿出文件，拼凑成我们的文件。这个格子就叫做数据块，又名 block。

在 centos 当中，默认的文件系统是 ext4，它在进入格式化的时候，它需要把硬盘划分为一个又一个等大小的数据块，这个数据块默认的标准大小为 4kb。假如有一个数据是 10kb，需要占用 3 个格子，最后一个格子只放了 2kb 数据，剩余的 2kb 空闲空间是不能再被其它文件所占用的，这 3 个格子不一定在一块。windows 中有一个磁盘碎皮整理，它的原理就是将保存的同一个文件的格子尽量放到一起，这样更有利于数据的读取。

## 硬件设备文件名
如果是 windows，在进行了分区、格式化之后，给分区分配盘符然后就可以直接使用了。但是 Linux 不行，Linux 在进行了分区、格式化，格式化完成之后，要想给分区分配盘符之前，**还必须给每一个分区起一个设备文件名，或者说给每一个分区起一个硬件设备文件名。**

在 Linux 中所有的硬件设备都是文件。

![硬件设备文件名](/upload_image/Hardware_Name.png "硬件设备文件名")

「/」表示 Linux 中的最高一级目录，也就是根目录。在根目录下有一个 dev 的一级子目录，在 dev 目录中放入的所有的文件都是**硬件文件**。我们将**硬件文件名**，称为**硬件的设备文件名**。

为什么 Linux 需要「硬件设备文件名」而 windows 不需要？
在 windows 中，硬盘分区、格式化之后，然后可以直接分配盘符是因为我们可以在 windows 的图形界面中直接看到这个硬盘在哪（注意：一台机器可能有多个硬盘），所以可以直接分配盘符（windows 有完善的图形界面）。但是 Linux 最早出现的时候，是没有图形界面的，为了让系统知道我要给哪一个硬盘分配盘符，所以被迫需要给每一个硬盘或者硬件设备指定设备文件名。

**硬件设备文件名是固定的，系统自动检测的，我们能看懂就行。** 关于硬盘，我们现在主要使用的是 SATA 硬盘接口，IDE、SCSI 硬盘接口基本被淘汰了。

## 分区设备文件名
硬盘有了「硬件设备文件名」，还要给分区也要分配文件名，这就是「分区设备文件名」。「分区设备文件名」是在硬盘「硬件设备文件名」之后，直接加分区号就可以了。即硬盘有设备文件名，分区也应该有设备文件名，区别是一个是硬件设备文件名，一个是分区设备文件名。

分区设备文件名：分区文件名是在硬盘文件名之后直接加分区号，1 表示这个硬盘当中的第一个分区，依次类推。**注意分区号有主分区号和逻辑分区号。**

逻辑分区是从 5 开始的，1234 只能给主分区或者扩展分区使用，即使一个硬盘中没有分够 4 个主分区，逻辑分区也不能占用 1234 这 4 个分区号，即不管如何分区 5 都表示逻辑分区的第一个分区。

## 挂载
windows 中分配盘符的操作在 Linux 中叫做挂载，我们把给分区分配盘符的过程称为挂载，我们把盘符叫做挂载点。在 Linux 中是使用空的目录名称作为盘符，而不是使用 CDEF 作为盘符，理论上任何一个目录都可以作为盘符，实际上有些目录是不可以的。

对于 Linux 来讲有两个必须分区：根分区、swap 分区（交换分区，大小一般为内存的 2 倍，一般不超过 2GB）。这两个是必须分区，如果不分区，则 Linux 不能安装，只要有这两个分区，Linux 就可以正常使用。还有一个推荐分区，/boot（启动分区，大小一般为 200M)。

根分区用于存放剩余数据，swap 分区可以理解为虚拟内存，即当我真正的内存不够用的时候可以拿交换分区的硬盘空间来当内存来用，理论上讲 swap分 区应该是内存的两倍，但是最大不超过 2GB，因为虚拟内存到底不是真正的内存，如果给它给的再大，它也不能取代内存，当它达到 2GB 的时候，如果再给大，只会占用我们更多的硬盘空间，但是对我们的系统不会产生更多的影响，所以最大不超过 2GB。

Boot 分区是专门用来保存启动时候的数据，任何操作系统启动的时候都需要一些硬盘空间，如果不给 boot 分区，万一根分区写满了，系统可能就启动不了了，为了解决这个问题，一般都会给 boot 单独分区。Boot 分区 200MB 足够，不用太大，写完之后不再往 boot 分区写入任何数据，它永远都会有一定的空余空间，就算把根分区写满了，也不会影响 Linux 启动。

## Linux 文件系统结构
![Linux 文件系统结构](/upload_image/File_System_Structure.png "Linux 文件系统结构")

从 Linux 系统上看，boot、home 都是根分区的子目录。但是从硬盘上来看，它们每一个目录都可以有自己独立的硬盘空间，即每一个目录都可以有自己独立的分区，而每个分区又对应某块硬盘空间，所以每个目录都可以有自己独立的硬盘空间。

挂载点就是分区的盘符，swap 分区即交换分区没有盘符，swap 分区不是给用户用的，是由 Linux 操作系统或者内核直接调用的，所以它根本不需要盘符，有了盘符反而不正确了。swap 对系统性能的影响极小，所以分的空间不用太大。

## 总结
> 分区：把大硬盘分为小的逻辑分区；
> 格式化：格式化的目的是为了写入文件系统，当然在写入文件系统的时候会附带的把硬盘当中的数据清空；
> 分区设备文件名：给每个分区定义设备文件名；
> 挂载：给每个分区分配挂载点，这个挂载点必须是目录，而且必须是空的目录才可以进行挂载点分配。
