---
title: 观察者模式
copyright: true
date: 2018-04-16 20:52:59
updated:
comments:
tags: 设计模式
categories: 设计模式
layout:
permalink:
top: 0
password:
---

<blockquote class="blockquote-center"> 设计模式 之 观察者模式 </blockquote>

<!-- more -->

## 使用场景
当对象间存在一对多关系时，则可以考虑使用观察者模式。例如：当一个对象被修改时，则会 主动 通知它的依赖对象，注意这里是 被依赖对象 主动通知 依赖对象，并且依赖对象被自动更新。

## 实现观察者模式
观察者模式使用 Subject、Observer 和 Observer 的一系列子类。Subject 对象带有绑定观察者到 被观察者 对象和从 被观察者 对象解绑观察者的方法。例如：A 类种执行 save 方法的时候，B、C 类打印一句话。那么 A 就是 Subject，A 类中维护了一个观察者的 List，并且提供了往这个 List 添加和删除观察者的 方法，如果A执行了 save 方法，则遍历 List 主动通知每一个观察者即 B 和 。

```java
观察者接口：
public abstract class Observer {    
    public abstract void update(String msg);
}

第一个观察者：
public class F_Observer extends Observer {
    public void update(String msg) {
        System.out.println(F_Observer.class.getName() + " : " + msg);
    }
}

第二个观察者：
public class S_Observer extends Observer {
    public void update(String msg) {
        System.out.println(S_Observer.class.getName() + " : " + msg);
    }
}

第三个观察者：
public class T_Observer extends Observer {
    public void update(String msg) {
        System.out.println(T_Observer.class.getName() + " : " + msg);
    }
}

被观察者：
public class Subject {        
    private List<Observer> observers = new ArrayList<>();    //状态改变    
    public void setMsg(String msg) {        
        notifyAll(msg);    
    }   
     //订阅    
    public void addAttach(Observer observer) {        
        observers.add(observer);    
    }    
    //通知所有订阅的观察者    
    private void notifyAll(String msg) {        
        for (Observer observer : observers) {            
            observer.update(msg);        
        }   
    }
}

使用方法：
public class Main {    
    public static void main(String[] args) {        
        F_Observer fObserver = new F_Observer();        
        S_Observer sObserver = new S_Observer();        
        T_Observer tObserver = new T_Observer();
                        
        Subject subject = new Subject();        
        subject.addAttach(fObserver);        
        subject.addAttach(sObserver);        
        subject.addAttach(tObserver);                
        subject.setMsg("msg change");    
    }
}

```

## 利用 Java 对观察者模式的支持类实现
Java 对观察者模式支持类为 Observable 和 Observer，位于 java.util 包中

```java
// 被观察者类，继承了 Observable 表示该类可被观察
import java.util.Observable;

public class Subject extends Observable{
    private Integer price;

    public void setPrice(Integer price) {
        // 价格发生了变化
        this.price = price;
        // 将 Observable 类中的 changed 设置为 true，表示发生了改变
        super.setChanged();
        // 这个方法被重载了，可以传参也可以不传，参数表示要通知的内容
        super.notifyObservers();
    }
}

// JDK 里面 Observable 类
public class Observable {
    private boolean changed = false;
    // 之所以使用 Vector 而不使用 List，是因为多线程操作时，Vector 是线程安全的，而 List 则是不安全的
    private Vector<Observer> obs;
    
    public Observable() {
        obs = new Vector<>();
    }
    
    // 向 Vector 中添加观察者    
    public synchronized void addObserver(Observer o) {
        if (o == null)
            throw new NullPointerException();
        if (!obs.contains(o)) {
            obs.addElement(o);
        }
    }
    
        
    public synchronized void deleteObserver(Observer o) {
        obs.removeElement(o);
    }
    
    public synchronized void deleteObservers() {
        obs.removeAllElements();
    }
    
    protected synchronized void setChanged() {
        changed = true;
    }
    
    protected synchronized void clearChanged() {
        changed = false;
    }
    
    public void notifyObservers() {
        notifyObservers(null);
    } 
    
    public void notifyObservers(Object arg) {
        Object[] arrLocal;
    
        synchronized (this) {
            if (!changed)
                return;
            arrLocal = obs.toArray();
            clearChanged();
        }
    
        for (int i = arrLocal.length-1; i>=0; i--)
            ((Observer)arrLocal[i]).update(this, arg);
    }
    
    public synchronized boolean hasChanged() {
        return changed;
    }
    
    public synchronized int countObservers() {
        return obs.size();
    }  
}     

// 观察者实现了 Observer 接口，并且复写了接口中的 update 方法，表示
import java.util.Observable;
import java.util.Observer;

public class Observer01 implements Observer {

    @Override
    public void update(Observable o, Object arg) {
        System.out.println(arg);
    }
}

// 
public class Client {
    public static void main(String[] args) {
        Observer01 o = new Observer01();
        Subject subject = new Subject();
        
        subject.addObserver(o);
        subject.setPrice(100);
    }
}
```

Java 对观察者模式的实现，其源码看似简单，但自己去实现这个类的时候，发现漏洞百出，不得不对源码的严谨程度折服。Observable 和 Observer 之间是依赖关系，即 Observer 的方法依赖于 Observable 类。

注意：观察者和被观察者是抽象耦合的，他们之间是关联关系，不是依赖关系，引用类为被观察者，被引用类为观察者，即 UML 类图中，实线箭头由被观察者指向观察者，即被观察者需要知道哪些观察者关注了它，它在改变的时候好挨个主动去通知观察者。代码表现为被观察者类中有观察者的引用。注意观察者和被观察者之间可能会存在循环依赖，从而导致系统崩溃。


[极客学院-观察者模式](http://www.runoob.com/design-pattern/observer-pattern.html)
[菜鸟教程-观察者模式](http://wiki.jikexueyuan.com/project/java-design-pattern/observer-pattern.html)
[Observer和Observable详解](https://blog.csdn.net/u012250875/article/details/77747878)
http://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html
