---
title: Java 反射机制
copyright: true
date: 2018-01-30 14:45:23
updated:
comments:
tags: Java 基础
categories: Java 基础
layout:
permalink:
top:
password:
---

<blockquote class="blockquote-center"> Java 反射机制 </blockquote>

<!-- more -->

## 认识 Class 类
反射 即通过一个对象来找到其所在类的信息。反射中所有的操作都是反着来的，用逆向思维去思考反射。


> 1、在 Object 类中定义了 public final native Class<?> getClass(); 被所有子类所继承。
> 2、注意其返回值类型是 Class,它是一个类；就跟 Person 类表示人，是创造人对象的模板，则 Class 类表示类，是创造类对象的模板。即 Class 是创建类的类，Class 类的实例是一个具体的类，Class 类表示所有的类。类比 Person 类的实例是一个具体的人，Person 类表示所有的人。

![反射](/upload_image/reflect.png "反射")

## Class 类的定义
Class 类是 Java 反射的源头。Class 本身表示一个类的本身，通过 Class 可以完整的得到一个类中的完整结构，包括此类的方法定义、属性定义等。

![Class 类常用方法](/upload_image/class_method.png "Class 类常用方法")

## 实例化 Class 类对象的三种方式（Class 类的构造方法被私有化了）
* 通过forName()方法，传入完成的“包.类”名称
* 类.class
* 对象.getClass()

```java
package cn.yan.reflect;

/**
 * Created by yanchongsheng on 2018/1/30.
 */

class X {}

// 实例化 Class 类对象的三种方式
public class Reflect {
    public static void main(String[] args) throws ClassNotFoundException {
        // 通过 forName() 方法
        Class<?> c1 = Class.forName("cn.yan.reflect.X");
        // 通过 类.class
        Class<?> c2 = X.class;
        // 通过 对象.getClass()
        Class<?> c3 = new X().getClass();
    }
}
```
    
一旦可以实例化Class类之后，即拿到 Class 类的实例化对象，就可以进行反射的进一步操作了。

## Class 类的使用
Class 类不仅可以取得对象所在类的信息，还<b>可以使用 Class 类的 newInstance()方法实例化对象，需要注意的是操作类中必须存在无参构造方法。因为该方式本质上利用的是类中的无参构造方法实例化对象，符合对象的实例化要求。</b>当然也可以调用有参构造方法来实例化对象，这就需要 Constructor 类的支持，使用该类中提供的newInstance(Object ... initargs) 明确表示要调用类中的有参构造方法，并向构造方法中传递参数，才可以进行实例化操作。

1、通过 Class 类种的 getConstructors() 取得本来中的全部构造方法。
2、向构造方法中传递一个对象数组进去，里面包含了构造方法所需的所有参数。
3、利用 Constructor 类中提供的 newInstance 方法完成实例化操作。

![Constructor 类常用方法](/upload_image/constructor_method.png "Constructor 类常用方法")

```java
package cn.yan.reflect;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class Test {
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InvocationTargetException, InstantiationException {
        Class c = Class.forName("cn.yan.reflect.Person");
        Constructor[] constructors = c.getConstructors();
        // 注意：参数值的顺序要跟调用的构造方法中的参数定义的顺序一致 
        Person person = (Person) constructors[0].newInstance("zhangsan",30);
        System.out.println(person);
    }
}

class Person {
    private String name;
    private Integer age;

    public Person(String name, Integer age) {
        this.name = name;
        this.age = age;
    }
}
```

注意：
1、调用 newInstance 方法时，传参的的顺序要跟其对应的构造方法中的参数定义的顺序一致
2、实例化对象使用的 newInstance 方法来自于 Constructor 类，而不是 Class 类

## 通过反射取得一个类的完整结构
要想通过反射取得一个类的完整结构，就要使用到 java.lang.reflect 包中的以下几个类：
* Constructor：表示类中的构造方法
* Field：表示类中的属性
* Method: 表示类中的方法
注意：在实际的开发中，取得类的信息的操作代码不是很常见；一定要熟悉 java.lang.reflect 包的作用；掌握如何取得属性、方法、构造的名称、类型、修饰符等。

## Java 的修饰符
在整个 Java 中，对于方法的修饰符是使用一定的数字表示出来的，而如果要想把这个数字还原成用户可以看得懂的关键字，则必须依靠 Modifier类完成，该类定义在 java.lang.reflect 包中，直接使用 Modifier 类中的 public static String toString(int mod) 方法即可将修饰符还原。

## 取得类中的方法
* Method[] getDeclaredMethods() 取得本类中的全部方法
* Method[] getMethods() 取得全部方法（包括父类、接口里面的方法）

要想进一步获取方法的具体信息，例如：方法的参数、抛出的异常等，就必须依靠 Method 类。
* Class<?> getReturnType() 取得方法的 返回值 类型
* Class<?>[] getParameterTypes 取得全部的 参数 类型
* Class<?>[] getExceptionTypes 取得异常信息
* int getModifiers() 取得修饰符

## 取得类中的属性
* Field[] getFields() 取得实现的接口或父类中的公共属性
* Field[] getDeclaredFields() 取得本类中的全部属性






通过Class类中的 public Method getMethod(String name, Class<?>... parameterTypes)
得到一个方法的的Method对象，然后通过Method对象来执行方法，但是在方法调用的时候牵
扯到方法中的参数的问题，所以通过getMethod()取得的时候，必须设置好需要的参数类型。然
后直接通过Method类中的 public Object invoke(Object obj, Object... args)执行方法调
用。执行的时候需要传递参数进去，而且需要实例化对象。

## setter、getter方法的操作原理

    package cn.yan;

    import java.lang.reflect.InvocationTargetException;
    import java.lang.reflect.Method;

    /**
     * Created by yanchongsheng on 2018/1/30.
     */
    public class InvokeSetGetDemo {
        public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException,
            InstantiationException, NoSuchMethodException, InvocationTargetException {
            Class<?> c = Class.forName("cn.yan.reflect.Person");
            Object obj = c.newInstance();
            setter(obj, "name", "tom", String.class);
            getter(obj, "name");
        }

        /**
         * Object obj：要操作的对象
         * String att：要操作的属性
         * Object value：要设置的属性内容
         * Class<?> type：要设置属性类型
         */
        public static void setter(Object obj, String att, Object value, Class<?> type) throws NoSuchMethodException,
            InvocationTargetException, IllegalAccessException {
            Method method = obj.getClass().getMethod("set" + initStr(att), type);
            method.invoke(obj, value);
        }

        public static Object getter(Object obj, String att) throws NoSuchMethodException, InvocationTargetException,
            IllegalAccessException {
            Method method = obj.getClass().getMethod("get" + initStr(att));
            return method.invoke(obj);
        }

        public static String initStr(String old) {
            String str = old.substring(0, 1).toUpperCase() + old.substring(1);
            return str;
        }
    }

    class Person {
        private String name;
        private Integer age;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public Integer getAge() {
            return age;
        }

        public void setAge(Integer age) {
            this.age = age;
        }
    }
