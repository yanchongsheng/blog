---
title: Linux 入门总结(十一)
copyright: true
date: 2018-10-25 19:59:38
updated:
comments:
tags: Linux 基础
categories: Linux 基础
layout:
permalink:
top:
password:
---

<blockquote class="blockquote-center"> Linux 入门总结(十一) —— Shell 基础 </blockquote>

<!-- more -->

## Shell 概述

1、Shell 是什么？
Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统程序，用户可以用 Shell 来启动、挂起、停止甚至编写一些程序。

Shell 还是一个功能相当强大的编程语言。Shell 是解释执行的脚本语言，在 Shell 中可以直接调用 Linux 系统命令。

2、Shell 的分类
Bourne Shell：从 1979 起 Unix 就开始使用 Bourne Shell，Bourne Shell 的主文件名为 sh。

C Shell：C Shell 主要在 BSD (Berkeley Software Distribution，是一个操作系统的名称，衍生自 Unix，被称为伯克利 Unix) 版的 Unix 系统中使用，其语法和 C 语言相类似而得名。

Shell 的两种主要语法类型有 Bourne 和 C，这两种语法彼此不兼容。Bourne 家族主要包括 sh、ksh、Bash、psh、zhs；C 家族主要包括：csh、tcsh。

Bash (Bourne Again Shell): Bash 与 sh 兼容，现在使用的 Linux 就是使用 Bash 作为用户的基本 Shell。

3、Linux 支持的 Shell
在 「/etc/shells」文件中保存着当前系统支持的 Shell。注意：只要是系统支持的 Shell，我们就可以通过输入对应的 Shell 名字来进行切换。

4、echo 输出命令
echo 是反射、回声的意思。是用来输出的命令。格式：`echo [选项][输出内容]`；选项：`-e`，支持反斜杠控制的字符转换。
eg：`echo 'Hello World!'`  注意：感叹号在 Shell 中有特殊的作用，所以这里使用单引号。

5、Linux 中常见的转义符
![Linux 中常见的转义符](/upload_image/Escape_Character.png "Linux 中常见的转义符")

eg：`echo -e "ab\bc"` 删除左侧字符；输出结果：`ac`；分析：`\b` 代表的是退格键。
eg：`echo -e "a\tb\tc\nd\te\tf"` 制表符与换行符。
eg: `echo -e "\e[1;31m abcd \e[0m"` 带颜色输出内容；输出结果：`红色的 abcd`；分析：31m=红色；「\e[1;」表示开启颜色输出，「\e[0m」	表示结束颜色输出。

6、第一个 Shell 脚本

```shell
#!/bin/Bash
#The first program
#Author: YanChongsheng E-mail: yanchongsheng@gmail.com
echo -e "YanChongsheng is the most handsome man in China."
```

注意：「#!/bin/Bash」这句话不是注释，而是标称，标称以下内容是 Shell 脚本。在 Linux 中以 # 号开头的是注释。

7、脚本执行
* 方式一：赋予执行权限，直接运行 `赋予权限：chmod 755 hello.sh 运行脚本：./hello.sh`
* 方式二：通过 Bash 调用执行脚本：`bash hello.sh`

注意：使用 base 执行脚本的时候，脚本甚至可以没有执行权限。它的意思是通过这个 Shell 来解释这个 shell 脚本文件，所以只要里面的内容是正确的，连执行权限都可以不用给就可以执行，但是最习惯的执行方法还是第一种。

cat 命令给其加上选项 -A ：表示查看所有的文件内容，包括隐藏字符，例如回车符就属于文件中的隐藏字符。在 Linux 中，回车符识别为「$」号。但是 Windows 中的回车符是「^M$」，表示这个 shell 是在 windows 中编辑完成的，要想在 Linux 中执行，就需要进行转换，利用命令: dos2unix [文件名]。注意：如果 dos2unix 命令没有则需要安装：`yum -y install dos2unix`。

## Bash 的基本功能

1、历史命令
```
格式：histor [选项][历史命令保存文件]
选项：
    -c  清空历史命令
    -w  把缓存中的历史命令写入历史命令保存文件「~./bash_histor」
```
注意：每次登陆之后所敲的命令都会放在 history 即内存中，并不会放入 ~/.bash_history 文件，而是等正常退出以后，才会将内存中的历史命令写入到 ~/.bash_history 文件中的。注意：-c 会清除内存中和文件中的所有的历史命令。

历史命令默认会保存 1000 条，可以在环境变量配置文件「/etc/profile」中进行修改 `HISTSIZE=1000` 注意：重新登录以后才会生效。如果超过 1000，则删除第 1 条命令，保存第 1001 条命令。

历史命令的调用：
1. 使用上、下箭头调用以前的历史命令
2. 使用「!n」调用第 n 条历史命令
3. 使用「!!」执行上一条命令
4. 使用「!字符」执行最后一条以该字符串开头的命令

2、命令别名：
设定命令别名：alias 别名='原命令'。注意：用命令行方式定义的别名它只会临时生效，一旦系统重启，这个别名就会消失。
查询命令别名：alias 别名

3、命令执行顺序
1. 第一顺位：执行用绝对路径或相对路径执行的命令。
2. 第二顺位：执行别名。
3. 第三顺位：执行 Bash 的内部命令。
4. 第四顺位：执行按照 $PATH 环境变量定义的目录查找顺序找到的第一个命令。

输出环境变量：`echo $PATH`

让别名永久生效：`vim /root/.bashrc` 注意：修改的是用户对应家目录下的「./bashrc」文件。rc 可以简单的理解为 user config 的简写，取 user 的最后一个字母 r 和 config 的第一个字母 c 组成 rc。

删除别名：`unalias 别名`

4、Bash 常用快捷键
![Bash 常用快捷键](/upload_image/Bash_Shortcut_Key.png "Bash 常用快捷键")

5、标准输入输出

|设备|设备文件名|文件描述符|类型|
|---|---|---|---|
|键盘|/dev/stdin|0|标准输入|
|显示器|/dev/stdout|1|标准输出|
|显示器|/dev/stderr|2|标准错误输出|

6、输出重定向
![输出重定向](/upload_image/Output_redirect.png "输出重定向")

注意：不是所有的命令都可以使用输出重定向的，这个命令必须得有输出才可以。
注意：错误输出中，2 和 大于号之间不能有空格。

![正确输出和错误输出同时保存](/upload_image/Output_All.png "正确输出和错误输出同时保存")

注意：「/dev/null」是 Linux 中的一个特殊文件，可以把它当成垃圾箱，相当于不保存任何输出。

7、输入重定向「注意：输入重定向了解即可」
```
格式：wc [选项][文件名]
选项：
    -c  统计字节数 (byte) print the byte counts
    -m  统计字符数 (character) print the character counts
    -w  统计单词数 (word)
    -l  统计行数 (line)
```

注意：wc 可以统计键盘输入，输入的行数、单词数、字节数，输入完成之后按 ctrl + d，结束并进行统计。注意回车换行符也会被当成字节进行统计。

把文件作为命令的输入：`命令<文件`。eg：`wc < anaconda-ks.cfg`

8、多命令顺序执行
![多命令顺序执行](/upload_image/Execute_Many_Command.png "多命令顺序执行")

eg：`ls; date; cd /user; pwd`
eg: `命令 && echo yes || echo no`

![例子](/upload_image/Example_Many_Command.png "例子")
命令 dd 是磁盘或者说是数据复制的命令，但是它不是 cp，cp 命令只能复制文件，但是 dd 命令能复制特殊文件，也能复制分区甚至整个硬盘，不仅复制分区或硬盘的数据，还复制分区或硬盘的文件系统。dd 主要是用来进行磁盘复制。

9、管道符
```
格式：命令1 | 命令2
```
`命令1` 的`正确输出`作为`命令2` 的`操作对象`。

注意：命令1 必须正确输出，否则命令2 不会正常执行。

10、grep 命令，在文件中搜索符合条件的字符串
```
格式：grep [选项] "搜索内容"
选项：
    -i  忽略大小写
    -n  输出行号
    -v  反向查找 (注意：-v 查找的是不匹配的行，即反向查找)
    --color=auto  搜索出的关键字用颜色显示
```

通配符
![通配符](/upload_image/Wildcard.png "通配符")

Bash 中的特殊符号
![Bash 中的特殊符号](/upload_image/Special_Character.png "Bash 中的特殊符号")

注意：通配符是用来匹配文件名的，起码在 Linux 系统当中是用来匹配文件名的。

$ 和 $() 的区别是：$ 是用于调用变量的值；而 $() 是用来引用系统命令。

## Bash 的变量

1、变量设置规则  
1. 变量名称可以由字母、数字、下划线组成，但是不能以数字开头。

2. 在 Bash 中，变量的默认类型都是字符串型，如果要进行数值运算，则必须指定变量类型为数值型。

3. 变量用等号连接值，**等号左右两侧不能有空格**。

4. 变量的值如果有空格，需要使用单引号或双引号包括。

5. 在变量的值中，可以使用「\」转义符。

6. 如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含 "$变量名" 或用 ${变量名} 包含。

7. 如果是把命令的结果作为变量值赋值给变量，则需要使用反引号或 $() 包含**命令**。

8. 环境变量名建议大写，便于区分。

环境变量名大写，目的是为了区分。因为环境变量会让 Linux 当中所有的 Shell 都能使用，Linux 的系统命令也是在所有的 Shell 中都能使用，但是系统命令都是小写，为了让系统命令和环境变量区分开，建议把环境变量都写成大写。

2、变量分类
1. 用户自定义变量
2. 环境变量：这种变量中主要保存的是和系统操作环境相关的数据。
3. 位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。
4. 预定义变量：是 Bash 中已经定义好的变量，变量名不能自定义，变量作用也是固定的。

其实位置参数变量是预定义变量的一种，由于位置参数变量相对来说较多，所以我们习惯上将位置参数变量单独作为一个分类。所以这两种变量的限制是一样的，只能更改值。

3、本地变量
用户自定义变量又称为本地变量。「$变量名」的作用是调用变量。
```
# 定义变量
aa=123

# 变量叠加
aa="$aa"456 # 结果：123456
aa=${aa}789 # 结果：123456789

# 变量调用
echo $name

# 变量查看
set

# 变量删除
unset name
```
set 命令：表示查看系统的所有变量，包括系统的环境变量，以及系统变量，自定义的变量。
总结：变量的定义、叠加、调用、查看、删除；变量的概念、变量的规则、变量的分类。

4、环境变量是什么？
用户自定义变量只在当前 Shell 中生效。（使用命令行定义的）环境变量会在当前 Shell 和这个 Shell 的所有子 Shell 当中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的 Shell 中生效。

5、设置环境变量
```
# 声明变量
export 变量名=变量值

# 查询变量
env

# 删除变量
unset 变量名

# 将已经定义好的本地变量变为环境变量
export 变量名
```

注意：系统当前本身就是在一个 Shell 里面，我们可以直接输入 csh、或 bash 表示进入对应的 Shell，而系统本身的 shell 就是 csh 或者 bash 的父 Shell，这样就创建了一个子 Shell，当然子 Shell 里面还可以有子子 Shell。

如何查询和确定 Shell 呢？
使用命令 `pstree`，它的作用是确定进程数。

6、系统常见环境变量
PATH：系统查找命令的路径。
```
# 输出 PATH
echo $PATH

# PATH 变量叠加
PATH="$PATH":/root/sh
```

PS1：定义系统提示符的变量

![定义系统提示符](/upload_image/PS1_Character.png "定义系统提示符")

eg：`PS1=[\u@\h \W]\$ `。注意习惯在 $ 最后加一个空格，要不然你的命令会紧挨着提示符 # 或者 $。这种写法只是临时生效。

注意：env 是专门用来查看当前系统的环境变量的。严格来说 PS1 并不是环境变量，因为 env 命令查看不到，必须使用 set 命令查看。虽然它不是环境变量，但是它是系统预留专门用作定义系统操作环境的一个变量。它是环境变量的一个子分支。

**注意：Linux 以冒号为分割符号。**

7、位置参数

![位置参数](/upload_image/Location_Param.png "位置参数")

位置参数变量最大的作用就是向程序中传递需要的值。它的好处是可以在命令执行的同时接受参数。

注意：位置参数变量的名称和作用都是固定的。我们能做的只是在里面传入不同的值。

注意：要想进行数值运算，必须加 $(()) 双小括号括起来，它才能进行数值计算，这是 Linux Shell 的标准格式。

注意：$# 不会计算命令本身，它计算的仅仅只是参数。

`$*` 和 $@ 的区别：`$*` 中的所有参数看成是一个整体。$@ 中的每个参数看成是独立的。

8、预定义变量
![预定义变量](/upload_image/Predefined_Variable.png "预定义变量")

其实位置参数变量就是预定义变量当中的一个分类，其特点是不能改变变量名，变量的作用也是固定的。

$? 用来接收和判断上一条命令是否正确执行。注意：&& || 利用的就是 $? 来判断上一条命令是否正确执行的。

9、接受键盘输入，read 会把键盘输入的数据赋值给后面的变量中
```
格式：read [选项] [变量名]
选项：
    -p "提示信息"：在等待 read 输入时，输出提示信息
    -t 秒数：read 命令会一直等待用户输入，使用此选项可以指定等待时间
    -n 字符数：read 命令只接受指定的字符数，就会执行
    -s：隐藏输入的数据，适用于机密信息的输入
```
注意：如果不加 -n 选项，read 命令在回车以后才会结束，如果加了 -n 选项，则字符数达到 -n 执行的数字，则自动结束 read 并执行。

## Bash 的运算符
注意：Linux 的 Shell 中变量的类型默认都是字符串型。

1、declare 声明变量类型
```
格式：declare [+/-][选项] 变量名
选项：
    -：给变量设定类型属性
    +：取消变量的类型属性

    -i：将变量声明为整型（integer）
    -x：将变量声明为环境变量
    -p：显示指定变量的被声明的类型
```

2、数值运算
```
aa=11
bb=22

# 方法1
declare -i cc=$aa+$bb

# 方法2
# 利用 expr 或 let 数值运算工具。注意：「+」号左右两侧必须有空格。
cc=$(expr $aa + $bb)

# 方法3
# $((运算式)) 或 $[运算式]
cc=$(($aa+$bb))
cc=$[$aa+$bb]
```

3、运算符
![运算符](/upload_image/Linux_Operator.png "运算符")

注意：此处数字越大，优先级越高。

4、变量测试与内容替换
![变量测试与内容替换](/upload_image/Variable_Alternative_Test.png "变量测试与内容替换")

主要作用：通过 x 的值来确定 y 的情况。这块内容了解即可，完全可以 if 语句来替代，只是系统提供的更简洁、高效一点，用到的时候查一下能看懂就行，不要可以去记忆。

## 环境变量配置文件

1、source 命令
```
格式：source 配置文件
或
格式：. 配置文件
```

注意：source 命令的作用是让你的配置文件生效，即让系统重新读取一遍配置文件。（正常情况下配置文件生效需要重新登录一次，但是利用 source 命令可以直让配置文件生效）。
注意：点「.」和配置文件之间有空格，点「.」其实就是 source 的缩写。

2、环境变量配置文件简介
环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如 PATH、HISTSIZE、PS1、HOSTNAME 等默认环境变量。

系统中主要的 5 类环境变量配置文件：
1. /etc/profile 的作用：USER 变量、LOGNAME 变量、MAIL 变量、PATH 变量、HOSTNAME 变量、HISTSIZE 变量、umask、调用 /etc/profile.d/*.sh 文件。
2. ~/.bash_profile 的作用：调用了 ~/.bashrc 文件、在 PATH 变量后面加入了 「:$HOME/bin」这个目录。
3. ~/.bashrc 的作用：定义默认别名、调用 /etc/bashrc。
4. /etc/bashrc 的作用：PS1 变量、umask、PATH 变量、调用 /etc/profile.d/*.sh 文件。
5. /etc/profile.d/*.sh

注意：只要是保存在 /etc 目录中的，表示对所有登录到该 Linux 系统的用户都生效。~/ 表示当前用户的家目录，「.」表示该文件是隐藏文件，这些配置文件针对的是当前用户。「~」表示家目录的意思。

3、环境变量配置文件作用

![环境变量配置文件调用顺序](/upload_image/Profile_Invoke_Order.png "环境变量配置文件调用顺序")

注意：环境变量默认赋值的时候分两种情况  
1.一种是用户通过输入用户名和密码的正常登陆。
2.一种是用户通过命令切换到子 Shell 的登陆，这种情况是没有输入用户名密码过程的。
这两种不同的登陆方法，它读取的配置文件是不一样的。

注意：环境变量配置文件它们之间是有优先级的。越后面读取的配置文件，其优先级越高，因为后面定义的变量会覆盖前面的变量。

需要输入用户名密码的正常登录情况配置文件的读取顺序：
/etc/profile「 ——> …… ——> /etc/sysconfig/i18n (新版的 Linux 为 /etc/locale.conf) 这些都是 /etc/profile 文件中调用的子文件或子子文件」当完成 /etc/profile 的所有调用以后 /etc/profile 就会将它的调用传递给下一个环境变量配置文件即 ~./bash_profile，然后照着上图依次往下传递。

发现 /etc/profile 和 /etc/bashrc 中有很多内容是重复的，如 PATH、umask、PS1，注意这个不是单单只是重复。你会发现 /etc/bashrc 中重复定义变量的地方有这样的注释「We're not a login shell」即该文件定义的是没有登录情况的 Shell 的环境变量。

4、注销时生效的环境变量配置文件
~/.bash_logout 默认为空，可以在里面写一些退出登录时候的操作，比如清空历史命令等操作。

5、其他配置文件
~/.bash_history 历史命令保存的地方。一般不要清空，但是有一种情况例外，比如你给某个服务设置密码，如 mysql，mysql 设置密码的时候使用的是明文（注意：是明文）系统命令，它会把密码记录在历史文件中，所以要清空明文密码记录。

6、Shell 登录信息
1.**本地**终端欢迎信息：/etc/issue
![本地终端转义符](/upload_image/Local_Terminal_Character.png "本地终端转义符")

注意：欢迎信息不要写 welcome 之类的，应该写的是警告信息。注意：针对的是本地登录。

2.**远程** 终端欢迎信息：/etc/issue.net
注意：转义符在 /etc/issue.net 文件中不能使用，即本地终端的转义符在这里都不能使用，这里只能写纯文本信息。是否显示此欢迎信息由 ssh 的配置文件 /etc/ssh/sshd_config 决定，加入「Banner /etc/issue.net」行才能显示。（记得重启 ssh 服务）。重启 ssh 服务：`service sshd restart`

3.**本地和远程**登录后欢迎信息：/etc/motd
不管是本地登录，还是远程登录，都可以显示此欢迎信息。但是，它是登录后的欢迎信息。刚才那两个文件是登录前的提示信息。
