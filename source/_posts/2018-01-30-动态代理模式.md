---
title: 动态代理模式
copyright: true
date: 2018-01-30 17:41:42
updated:
comments:
tags:
categories: Java设计模式
layout:
permalink:
top:
password:
---

静态代理简单的不要不要的，动态代理始终不得其精髓，差一个字差距太特么大了，学反射的时
候初识动态代理，学AOP的时候用到了动态代理的思想，前后n多次看，始终无法融会贯通,看过
n多博客，大多闲聊扯淡，除了讲怎么用，思想啥的屁也没讲，无奈自己总结一个吧。

<!-- more -->

## 首先明确一下代理的作用或者说好处：
在不改变原来代码的情况下，对原来的功能进行了增强，说白了就是开闭原则，还不理解的自
行Google。静态代理存在局限性，一个代理类只能为一个接口服务，如果有很多接口的话，则
必须提供很多的代理类，而且所有的代理操作除了调用的方法不一样之外，其他的操作都一样
所以存在了大量的重复代码。解决办法就是动态代理，把不同的操作提出去，生成一个类，专
门处理不同，剩下的就都相同了。

## 代理的实现分为：
静态代理：代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 class 文件。
动态代理：代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 class 文件，而是在运行时动态生成的类字节码，并加载到JVM中。

## Java 实现动态代理

### Java实现动态代理的大致步骤如下：
>1、定义一个委托类和公共接口。

第一点是人感觉都能看得懂，当然看不懂的，有部分也是人，哈哈哈。过于简单，自行Google

>2、自己定义一个类（调用处理器类，即实现 InvocationHandler 接口），这个类的目的是
 指定运行时将生成的代理类需要完成的具体任务（包括Preprocess和Postprocess），即代
 理类调用任何方法都会经过这个调用处理器类。

 分析：我们尝试一个字一个字的去理解这段话，注意是一个字一个字的去理解它的意思，否
 则你屁也得不到。首先调用/处理器/类：表示它是一个类，用来处理调用的类。即不管是谁,
 只要涉及到调用就会被处理器处理。就像汽车收费站，你要想通过，就必须受它检查。这个
 类的目的是：指定运行时将生成的代理类需要完成的具体任务：表示这个类是一个操作的模
 板，它是对一些操作的抽象，即把要在代理类中的操作拿出来，放到另一个类里面。本来这
 些操作是要直接写在代理类中的，但是我现在把这部分代码拿出去了，抽象成一个类了。用
 的时候呢，把这个类的实例放进去就可以了。既然都把代理类的操作都拿出去了，那么代理
 类调用任何方法肯定都要经过这个调用处理器类（即收费站）。假如我要对某些方法加强,则
 我只要在这个抽象出来的操作类里面动手脚就行（即收费站给每辆通过的车都发一个计费卡)
 不管什么方法（车），只要通过我这个处理器类(收费站),那么它就会得到加强(车得到卡)。

>3、生成代理对象（当然也会生成代理类），需要为他指定(1)委托对象(2)实现的一系列接口
 (3)调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理
 器实例。

 分析：类比静态代理类，要想构造出一个静态代理类需要的条件：委托对象即源对象、源对象
 实现的接口、被代理的方法（此处用调用处理器类的实例表示，因为这些操作都被抽象成一个
 类了，是操作的类，所以你需要一个具体的操作，所以是其对应类的实例）。

### Java 实现动态代理主要涉及以下几个类：
* java.lang.reflect.Proxy: 这是生成代理类的主类，通过 Proxy 类生成的代理类都继承
了 Proxy 类，即 DynamicProxyClass extends Proxy.(注意：这里的DynamicProxyClass
表示的是一系列动态生成的代理类，不是这个类就叫这个名字)
* java.lang.reflect.InvocationHandler: 这里称他为"调用处理器"，它是一个接口，我们动
态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现InvocationHandler 接口。

可以将InvocationHandler接口的子类想象成一个代理的最终操作类，替换掉ProxySubject类
![InvocationHandler接口](/upload_image/InvocationHandler.png "InvocationHandler接口")

这个函数是在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数
method不同，第一个参数是代理对象（表示哪个代理对象调用了method方法），第二个
参数是 Method 对象（表示哪个方法被调用了），第三个参数是指定调用方法的参数。

动态生成的代理类具有几个特点：
* 继承 Proxy 类，并实现了在Proxy.newProxyInstance()中提供的接口数组。
* public final。
* 命名方式为 $ProxyN，其中N会慢慢增加，一开始是 $Proxy1，接下来是$Proxy2...
* 有一个参数为 InvocationHandler 的构造函数。这个从 Proxy.newProxyInstance() 函数
内部的clazz.getConstructor(new Class[] { InvocationHandler.class }) 可以看出。

>Java 实现动态代理的缺点：因为 Java 的单继承特性（每个代理类都继承了 Proxy 类），
>只能针对接口创建代理类，不能针对类创建代理类。

分析：由于每个动态生成的代理类都继承了Proxy类，而Java有单继承的限制，所以要想实现
类的动态代理，则代理类和被代理类应该有相同的父类才可以被代理，但是由于代理类默认
继承了Proxy类，所以Java不能针对类创建代理类。

![Proxy类](/upload_image/Proxy.png "Proxy类")

要想得到一个加载器的对象，则肯定需要Class类完成，即Class类的getClassLoader()方法.
ClassLoader表示类的加载器，对于Java来说类加载器主要有三种：
![类加载器](/upload_image/ClassLoader.png "类加载器")

这个静态函数的第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM
的方法区），因为代理类是在运行时动态生成的，要想其能正常使用，所以要指定一个
类加载器来将动态生成的代理类加载到JVM然后运行。第二个参数是接口（表明你这个代
理类需要实现哪些接口），类比静态代理类，代理类和真实主题类要实现同样的接口。
第三个参数是调用处理器类实例（指定代理类中具体要干什么）。这个函数是 JDK 为了
程序员方便创建代理对象而封装的一个函数，因此你调用newProxyInstance()时直接创
建了代理对象（略去了创建代理类的代码）。其实他主要完成了以下几个工作：

    static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler handler)
    {
        //1. 根据类加载器和接口创建代理类
        Class clazz = Proxy.getProxyClass(loader, interfaces);
        //2. 获得代理类的带参数的构造函数，注意它的参数
        Constructor constructor = clazz.getConstructor(new Class[] { InvocationHandler.class });
        //3. 创建代理对象，并制定调用处理器实例为参数传入，注意它的参数
        Interface Proxy = (Interface)constructor.newInstance(new Object[] {handler});
    }

### 动态代理代码如下
    import java.lang.reflect.InvocationHandler;
    import java.lang.reflect.Method;
    import java.lang.reflect.Proxy;

    /**
     * Created by yanchongsheng
     */
    public class DynamicProxyDemo {
        public static void main(String[] args) {
            RealSubject realSubject = new RealSubject();    //1.创建委托对象
            ProxyHandler proxyHandler = new ProxyHandler(realSubject);  //2.创建调用处理器对象
            Subject proxySubject = (Subject) Proxy.newProxyInstance(realSubject.getClass().getClassLoader(),
                    realSubject.getClass().getInterfaces(), proxyHandler);
            proxySubject.request();
        }
    }

    interface Subject {
        void request();
    }

    class RealSubject implements Subject {
        public void request() {
            System.out.println("RealSubject Request");
        }
    }

    class ProxyHandler implements InvocationHandler {
        private Subject subject;
        public ProxyHandler(Subject subject) {
            this.subject = subject;
        }
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            System.out.println("====before====");
            Object result = method.invoke(subject, args);
            System.out.println("====after====");
            return result;
        }
    }

### 动态代理类的内部实现
现在我们就会有一个问题： Java 是怎么保证代理对象调用的任何方法都会调用 InvocationHandler 的 invoke() 方法的？

这就涉及到动态代理的内部实现。假设有一个接口 Subject，且里面有 int request(int i) 方法，则生成的代理类大致如下：

    final class $Proxy1 extends Proxy implements Subject {
        private InvocationHandler h;
        private $Proxy1() {};
        public $Proxy1(InvocationHandler h) {
            this.h = h;
        }

        public void request() {
            Method method = Subject.class.getMethod("request", new Class[]{int.class}); //创建method对象
            return (Integer)h.invoke(this, method, new Object[]{new Integer(i)}); //调用了invoke方法
        }
    }

参考博客：https://www.jianshu.com/p/6f6bb2f0ece9