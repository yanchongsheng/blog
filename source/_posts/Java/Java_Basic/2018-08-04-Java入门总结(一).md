---
title: Java 入门总结(一)
copyright: true
date: 2018-08-04 22:29:19
updated:
comments:
tags: Java 基础
categories: Java 基础
layout:
permalink:
top:
password:
---

<blockquote class="blockquote-center"> Java 入门总结(一) </blockquote>

<!-- more -->

1、在一个 `*.Java` 文件中，「至多有一个」 public 声明的**类**，「注：这里的**类**特指：class、interface、@interface、enum」但是允许有 0 个或多个不带 public 声明的**类**。如果存在 public 声明的**类**，则文件名称必须与 public 声明的类名称一致。如果一个 `*.Java` 文件中有多个 class 定义，则编译之后会自动划分为多个 `*.class` 文件。


2、Java 中的标识符可以由任意的字母、数字、下划线、美元符号组成，但是不能以数字开头，不能是 Java 中的保留关键字。不能用作 Java 命名的词：关键词、保留关键词「goto、const」、具有特殊意义的单词「true、false、null」。


3、变量：将内存中的某个内存块保留下来以供程序使用，里面的内容是可变的。常量：一个数字就表示常量，常量内容是不会改变的「比如：数字 1 就是常量，能改变吗？不能啊！」。


4、Java 数据类型划分

![数据类型划分](/upload_image/DataType.png "数据类型划分")


5、Java 八大基本数据类型
![Java 八大基本数据类型](/upload_image/BasicDataType.png "Java 八大基本数据类型")


6、数据的溢出  
当「**整数**」的数据大小超出了可以表示的范围，而程序中又没有做数值范围的检查时，这个整数变量所「**输出**」的值将发生紊乱，而不是预期的运行结果。「注意：这里的**整数**包括：byte、short、int、long 四种类型」。   

对于其他基本数据类型：char 如果超出其取值范围则什么也不会输出。float 和 double 超出其取值范围，输出的值跟其取值范围的值一样，超出部分算精度丢失了。

![整数超出取值范围](/upload_image/BeyondRange.png "整数超出取值范围")


7、Java 中字符占 2 个字节，取值范围 0~65535，计算机将字符当成整数来处理。

![常用转义字符](/upload_image/CommonChar.png "常用转义字符")


8、在 Java 中，boolean 类型的值只有 true 和 false，不存在用 0 或 1 表示的情况，也不存在和 0 或 1 转换的情况。


9、Java 中，整型和浮点型（float 或 double）做运算，其结果都是浮点型，因为 Java 的自动转型机制所定，首先它们都是数字，其次浮点型表示的范围比整型大，所以向浮点型自动转型。


10、浮点型向整型做强制类型转换，采取的是丢弃小数部分，只保留整数部分的机制。


11、Java 运算符
> Java 中一「单」、二、三目运算符，这里的数字指参与运算的对象「即变量」的个数。

* 赋值运算符：「=」
* 一元运算符：「+、-、!」
* 算术运算符：「+、-、*、/、%」
* 关系运算符：「>、<、>=、<=、==、！=」
* 逻辑运算符：「&、&&、|、||」
* 括号运算符：「()」
* 位运算符：「&、|、^、<<、>>、>>>」
* 自增与自减运算符：「++、--」


12、位运算符
如果要想进行位操作，则需要先将十进制的数据变为二进制数据，除 2 的形式，即除基取余。
![除基取余](/upload_image/GetBinaryData.gif "除基取余")

位运算操作：
![位运算符](/upload_image/ByteOperation.png "位运算符")

如何将一个十进制数转变为计算机中存储的二进制数
```Java
public class Test {
    // 如何将一个十进制数转变为计算机中存储的二进制数「以 『int b = -3;』 为例」
    if (是否是整数) {
        // 是整数
        对整数的绝对值进行除 2  取余操作，求得其二进制数，即真值。「b 的值为 -3，-3 的绝对值是 3，3 的二进制数为 11」
        判断整数的类型是哪个？从而决定它的位数 「b 的类型为 int，在内存中占 4 字节，即 32 位」
        if (真值的位数是否小于等于变量类型的位数) {
            if (是否是负数) {
                // 是负数
                「1 + 29 个 0 + 11（2 位） = 32 位」
                最高位为 1，其他位补零，得到其原码，然后再进行反码->补码->得到该负数在计算机中二进制的存储格式
            }else {
                // 是自然数，原码 = 反码 = 补码
                「30 个 0 + 11（2 位） = 32 位」
                高位补 0，求得其原码也即补码，得到该整数在计算机中二进制的存储格式
            }
        }
    }else {
        // 不是整数，直接报错
    }
}
```

> **位操作注意事项：**  
> 1.位操作只能用于整型数据，对 float 和 double 类型进行位操作会被编译器报错。「这里的整型数据指的是 long、int、char、short、byte」。  

> 2.位操作符的运算优先级比较低，所以尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。

> 3.位操作还有一些复合操作符，如&=、|=、 ^=、<<=、>>= 。

> 4.short、 byte、char 在移位之前首先将数据转换为 int，然后再移位，此时移位符号作用在 32 位 bit 上，并且右操作数只有低５位有效。

> 5.当左操作数是 long 时，移位之后得到的类型是 long，当左操作数是其它四中类型时，移位之后得到的类型是 int，所以如果做操作数是 byte,char,short 时，你用　>>=,>>>=, <<= 其实是将得到的 int 做**低位截取**得到的数值。


13、原码、反码、补码  
> 原码：就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。  

> 反码：正数的反码是其本身；负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。  

> 补码：正数的补码就是其本身；负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后 +1。「即在反码的基础上 +1」。

> ** 注意：负数在计算机中是以补码的形式存储的。**



## 参考博客
[Java 中 boolean 类型占用多少个字节](https://www.jianshu.com/p/2f663dc820d0)  
[char，byte或者short进行移位处理](https://blog.csdn.net/qq1623267754/article/details/35771995)  
[Java 中 8 种基本数据类型](https://blog.csdn.net/lingdianalex/article/details/71424780)  
[Java 位操作全面总结](https://my.oschina.net/xianggao/blog/412967)  
[Java 运算符的优先级](https://www.jianshu.com/p/9d2204712097)  
[Java运算符优先级](https://www.jianshu.com/p/a65c54c26380)
[原码,反码,补码详解](http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)  
[Java 移位操作符](https://www.jianshu.com/p/0236b51b903f)
