---
title: Java反射机制基础篇
copyright: true
date: 2018-01-30 14:45:23
updated:
comments:
tags: Java 基础
categories: Java 基础
layout:
permalink:
top:
password:
---

Java反射这块的东西，每次看，每次像是都看懂了，每次都忘记，受不了了，我要跳出这个循环,
所以在此以blog的方式记录下我一个字一个字去学习Java反射的基础的过程，方便忘记的时候去
查询自己此时此刻逐字学习的结果。

<!-- more -->

## 认识Class类
反射：重点在“反”字上，即所有的操作都是反着来的，逆向思维。

正常情况下：知道类的完整路径然后才可以实例化对象。
反过来就是：知道实例化对象然后找到其所在类的信息。

    package cn.yan.reflect;

    /**
     * Created by yanchongsheng
     */

    class X {}

    // 由X类的实例找到其所在类的信息
    public class Reflect {
        public static void main(String[] args) {
            X x = new X();
            System.out.println(x.getClass().getName()); // 打印结果:cn.yan.reflect.X
        }
    }

在Object类中定义了以下的方法，被所有子类继承：
> public final native Class<?> getClass();
>注意其返回值类型是Class,它是一个类;就跟Person类表示人，是创造人对象的模板，则Class类表示类，是创造类对象的模板。

![反射图](/upload_image/reflect.png "reflect image")

Class类，Java反射的源头。Class本身表示一个类的本身，通过Class可以完整的得到一个类中完整的结构。

Class类的构造方法被私有化了，实例化Class类对象的方法有三种方式：
* 通过forName()方法，传入完成的“包.类”名称
* 类.class
* 对象.getClass()


    package cn.yan.reflect;

    /**
     * Created by yanchongsheng on 2018/1/30.
     */

    class X {}

    // 实例化Class类对象的三种方式
    public class Reflect {
        public static void main(String[] args) throws ClassNotFoundException {
            // 通过forName()方法
            Class<?> c1 = Class.forName("cn.yan.reflect.X");
            // 通过类.class
            Class<?> c2 = X.class;
            // 通过对象.getClass()
            Class<?> c3 = new X().getClass();
        }
    }

一旦实例化Class类之后，就可以进行反射的进一步操作了。就跟你拿到钱以后，就可以干很多事一个道理。

## Class类的使用 之 利用Class类实例化对象
可以使用Class类的newInstance()方法实例化对象，但是操作类必须存在无参构造方法。该方式
实际上还是需要类中构造方法支持的，符合对象的实例化要求。当然也可以直接调用有参构造方
法来实例化对象，这就需要Constructor类的支持，使用其newInstance(Object ... initargs)
方法,向构造方法中传递参数，实例化对象。

## 通过反射调用类中的方法
通过Class类中的 public Method getMethod(String name, Class<?>... parameterTypes)
得到一个方法的的Method对象，然后通过Method对象来执行方法，但是在方法调用的时候牵
扯到方法中的参数的问题，所以通过getMethod()取得的时候，必须设置好需要的参数类型。然
后直接通过Method类中的 public Object invoke(Object obj, Object... args)执行方法调
用。执行的时候需要传递参数进去，而且需要实例化对象。

## setter、getter方法的操作原理

    package cn.yan;

    import java.lang.reflect.InvocationTargetException;
    import java.lang.reflect.Method;

    /**
     * Created by yanchongsheng on 2018/1/30.
     */
    public class InvokeSetGetDemo {
        public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException,
            InstantiationException, NoSuchMethodException, InvocationTargetException {
            Class<?> c = Class.forName("cn.yan.reflect.Person");
            Object obj = c.newInstance();
            setter(obj, "name", "tom", String.class);
            getter(obj, "name");
        }

        /**
         * Object obj：要操作的对象
         * String att：要操作的属性
         * Object value：要设置的属性内容
         * Class<?> type：要设置属性类型
         */
        public static void setter(Object obj, String att, Object value, Class<?> type) throws NoSuchMethodException,
            InvocationTargetException, IllegalAccessException {
            Method method = obj.getClass().getMethod("set" + initStr(att), type);
            method.invoke(obj, value);
        }

        public static Object getter(Object obj, String att) throws NoSuchMethodException, InvocationTargetException,
            IllegalAccessException {
            Method method = obj.getClass().getMethod("get" + initStr(att));
            return method.invoke(obj);
        }

        public static String initStr(String old) {
            String str = old.substring(0, 1).toUpperCase() + old.substring(1);
            return str;
        }
    }

    class Person {
        private String name;
        private Integer age;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public Integer getAge() {
            return age;
        }

        public void setAge(Integer age) {
            this.age = age;
        }
    }
